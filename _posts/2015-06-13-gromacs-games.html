---
layout: post
title: Gromacs games
date: '2015-06-13T12:00:00.006-07:00'
author: jandom
tags: 
modified_time: '2015-06-13T12:01:17.793-07:00'
blogger_id: tag:blogger.com,1999:blog-2967594273163880803.post-1351891523484182067
blogger_orig_url: https://jandomanski.blogspot.com/2015/06/gromacs-games.html
---

<br /><h4>Additional energy terms in custom Hamiltonians, exchanges</h4>The standard energy function in looks something like this:<br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">E = E_bonds + E_angles + E_dihedrals + E_LJ + E_Culombic</span><br /><br />This energy term, at some temperature T then becomes:<br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">U = exp(-E/kb*T)</span><br /><br />Let's say one has a n such Hamiltonians, U1...Un. These can then exchange, if the energies overlap. The details of the exchange scheme are skipped here, for gromacs implementation if the exchange see src/kernel/repl_ex.c<br /><br />In temperature replica exchange one uses a ladder of T values, hoping that U1...Un overlap. In solute tampering replica exchange, one modifies the energy function E, keeping the T constant, hoping again to see exchange.<br /><br />In deciding if a pair of replicas on a ladder will exchange, one compares their potential energy (Epot). <br /><br />When including extra energy terms into the hamiltonian (custom biases, for example) one has to make sure they will be included in the Epot. <br /><br />For instance, let's see if the gromacs pull code adds its energy to epot (such that it can be exchanged)<br /><br />pull_potential_wrapper defined in src/mdlib/sim_util.c will call the pull_potential function and and save the energy to an enerd object:<br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">enerd-&gt;term[F_COM_PULL] += pull_potential(...);</span><br /><br />pull_potential_wrapper is called both in do_force_cutsGROUP and do_force_cutsVERLET (all inside of src/mdlib/sim_util.c).<br /><br />Immediately after computing the pull potential, the code calls sum_epot function, let's have a look at that:<br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">void sum_epot(t_grpopts *opts, gmx_grppairener_t *grpp, real *epot)<br />{<br />&nbsp;&nbsp;&nbsp; int i;<br /><br />&nbsp;&nbsp;&nbsp; /* Accumulate energies */<br />&nbsp;&nbsp;&nbsp; epot[F_COUL_SR]&nbsp; = sum_v(grpp-&gt;nener, grpp-&gt;ener[egCOULSR]);<br />&nbsp;&nbsp;&nbsp; epot[F_LJ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = sum_v(grpp-&gt;nener, grpp-&gt;ener[egLJSR]);<br />&nbsp;&nbsp;&nbsp; epot[F_LJ14]&nbsp;&nbsp;&nbsp;&nbsp; = sum_v(grpp-&gt;nener, grpp-&gt;ener[egLJ14]);<br />&nbsp;&nbsp;&nbsp; epot[F_COUL14]&nbsp;&nbsp; = sum_v(grpp-&gt;nener, grpp-&gt;ener[egCOUL14]);<br />&nbsp;&nbsp;&nbsp; epot[F_COUL_LR]&nbsp; = sum_v(grpp-&gt;nener, grpp-&gt;ener[egCOULLR]);<br />&nbsp;&nbsp;&nbsp; epot[F_LJ_LR]&nbsp;&nbsp;&nbsp; = sum_v(grpp-&gt;nener, grpp-&gt;ener[egLJLR]);<br />&nbsp;&nbsp;&nbsp; /* We have already added 1-2,1-3, and 1-4 terms to F_GBPOL */<br />&nbsp;&nbsp;&nbsp; epot[F_GBPOL]&nbsp;&nbsp; += sum_v(grpp-&gt;nener, grpp-&gt;ener[egGB]);<br /><br />/* lattice part of LR doesnt belong to any group<br />&nbsp;* and has been added earlier<br />&nbsp;*/<br />&nbsp;&nbsp;&nbsp; epot[F_BHAM]&nbsp;&nbsp;&nbsp;&nbsp; = sum_v(grpp-&gt;nener, grpp-&gt;ener[egBHAMSR]);<br />&nbsp;&nbsp;&nbsp; epot[F_BHAM_LR]&nbsp; = sum_v(grpp-&gt;nener, grpp-&gt;ener[egBHAMLR]);</span><br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; /* Sum all the values in the epot (list of floats) to a value at F_EPOT index */</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; epot[F_EPOT] = 0;<br />&nbsp;&nbsp;&nbsp; for (i = 0; (i &lt; F_EPOT); i++)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (i != F_DISRESVIOL &amp;&amp; i != F_ORIRESDEV)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; epot[F_EPOT] += epot[i];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; }<br />}</span><br /><br />In the first half of this function call, nothing useful happens. The second half where epot is iterated over (epot is the same as <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">enerd-&gt;term earlier on</span>), and accumulated.<br /><br />Because F_COM_PULL comes before F_EPOT in include/types/idef.h, it will be included in the epot summation.<br /><h4>Multiple input files</h4>This is a minor, utility hack. Normally, mdrun uses a single input file - for example:<br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">mdrun -s topol.tpr -o traj.xtc</span><br /><br />For replica exchange simulations however, these become mulitple files - the command <br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">mdrun -multi 2 -s topol.tpr -o traj.xtc</span><br /><br /><br />Will initialize from 2 .tpr files topol0.tpr and topol1.tpr, it will also write two traj output files.<br /><br />How to add additional files that will be read in with replica exchange simulations? Modify the following file<br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"># src/gmxlib/main.c</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp; else if (bParFn)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Patch output and tpx, cpt and rerun input file names */<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = 0; (i &lt; nfile); i++)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Because of possible multiple extensions per type we must look<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * at the actual file name<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (is_output(&amp;fnm[i]) ||<br /><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fnm[i].ftp == efTPX || fnm[i].ftp == efCPT || </b><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcmp(fnm[i].opt, "-rerun") == 0)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftp = fn2ftp(fnm[i].fns[0]);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; par_fn(fnm[i].fns[0], ftp, cr, TRUE, FALSE, buf, 255);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sfree(fnm[i].fns[0]);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fnm[i].fns[0] = gmx_strdup(buf);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; }</span><br /><br />Which should become:<br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">fnm[i].ftp == efTPX || fnm[i].ftp == efCPT || fnm[i].ftp == efCUSTOM ||</span><br /><br />