---
layout: post
title: React.js – edit and delete comments in CommentBox
date: '2015-02-16T15:20:00.000-08:00'
author: jandom
tags: 
modified_time: '2015-02-20T07:45:27.476-08:00'
blogger_id: tag:blogger.com,1999:blog-2967594273163880803.post-130051517674389643
blogger_orig_url: https://jandomanski.blogspot.com/2015/02/reactjs-first-steps-extending-comment.html
---

It appears customary for high-intelligence, high-skills groups of engineers to "roll their own" whenever they have a chance to. Counter-intuitively to most managerial/MBA types out there, re-inventing the wheel can give you... a better wheel. Success is not guaranteed though – but these people may leave sooner rather than later if you don't let them...<br /><br />Having looked at number of JS frameworks (ember, backbone, angular) there was no clear winner. They were all a mess, at least to me. So I approached React.js with no hopes – how much better could it possible be? It turns out, a lot!<br /><br />This post will be an extension of the <a href="http://facebook.github.io/react/docs/tutorial.html">official React.js tutorial</a>. The tutorial stops at the stage where you can add comments to a dynamic lists, that will grow as you add comments. This falls short of the functionality displayed on facebook: once you add a comment you can edit or delete it, so that's what're going to do. Full disclosure, I only started using React this weekendo so my guide will inevitably be 'imperfect'.<br /><br />Let's start by modifying the Comment render method, to show the form editing form:<br /><br /><script class="brush: javascript" type="syntaxhighlighter"><![CDATA[ var Comment = React.createClass({   getInitialState: function() {       return { isEditing: false };   },    handleUpdate: function(e) {       e.preventDefault();       console.log("handleUpdate", e);   },      handleDelete: function(e) {        e.preventDefault();        console.log("handleDelete");   },     toggleEditing: function(e) {       e.preventDefault();       this.setState({isEditing: !this.state.isEditing});   },   render: function() {     return (       <div className="comment">        <h2 className="commentAuthor">          {this.props.author}         </h2>        {this.props.text}       </div>      <div className="commentActions">        <div className={ this.state.isEditing ?  'hidden':'' }>            <a href="#" onClick={this.toggleEditing}>Edit</a> | <a href="#" onClick={this.handleDelete} >Delete</a>          </div>          <div className={ this.state.isEditing ?  '':'hidden' }>            <a href="#" onClick={this.toggleEditing}>Done editing</a>          </div>        </div>        <div className={ this.state.isEditing ?  '' : 'hidden'}>          <form className="commentForm" onSubmit={this.handleUpdate}>            <input type="text" defaultValue={ this.props.text } ref="text"  />            <input type="submit" value="Confirm changes" />             </form>        </div>      </div>    );   } }); ]]></script>So now our Comment is willing and ready to be edited. But the CommentList in not aware of it, the handleDelete and handleUpdate methods cannot be propagated anywhere. Let's modify the CommentList to make the propagation possible:  <script class="brush: javascript" type="syntaxhighlighter"><![CDATA[ var CommentList = React.createClass({   handleDelete: function(id) {       this.props.onCommentDelete(id);   } ,   handleUpdate: function(id, data) {       this.props.onCommentUpdate(id, data)   } ,   render: function() {     var commentNodes = this.props.data.map(function (comment) {       var handle_delete = this.handleDelete.bind(this, comment.id);       var handle_update = this.handleUpdate.bind(this, comment.id);       return (         <Comment author={comment.author} text={comment.text} key={comment.id} onCommentDelete={handle_delete} onCommentUpdate={handle_update}>         </Comment>      );     });     return (       <div className="commentList">        {commentNodes}       </div>    );   } }); ]]></script>So CommentList has mystery props onCommentDelete and onCommentUpdate, let's not worry about them for now. What's important and is that we initialize the Comment component with two bindings onCommentDelete and onCommentUpdate. They link the Comment component back to the CommentList. Let's go back to the Comment and finish the work there. <script class="brush: javascript" type="syntaxhighlighter"><![CDATA[ var Comment = React.createClass({   //   handleUpdate: function(e) {       e.preventDefault();       var text = this.refs.barcode.getDOMNode().value.trim();       if (!text ) {         return;       }       this.props.onCommentUpdate({text: text});       this.setState({isEditing: !this.state.isEditing});   },      handleDelete: function(e) {        e.preventDefault();        this.props.onCommentDelete();   },   // }); ]]></script>So the Comment handleUpdate and handleDelete will simply look back to the props methods we've bound in the CommentList. To actually do anything, we have to make the CommentBox aware of what's going on.  <script class="brush: javascript" type="syntaxhighlighter"><![CDATA[ var CommentBox = React.createClass({   //   handleCommentDelete: function (id) {          var url = this.props.url.concat("/",id,".json","?apikey=",this.props.apikey);          $.ajax({          url: url,          dataType: 'json',          type: 'DELETE',          success: function(data) {            this.setState({data: data});          }.bind(this),          error: function(xhr, status, err) {            console.error(this.props.url, status, err.toString());          }.bind(this)        });   },   handleCommentUpdate: function(id, comment) {       var url = this.props.url.concat("/",id,".json","?apikey=",this.props.apikey);       $.ajax({           url: url,           dataType: 'json',           type: 'PATCH',           data: comment,           success: function(data) {             this.setState({data: data});           }.bind(this),           error: function(xhr, status, err) {             console.error(this.props.url, status, err.toString());           }.bind(this)         });   },   //   render: function() {     return (       <div className="commentBox">        <h1>Comments</h1>        <CommentList data={this.state.data} onCommentDelete={this.handleCommentDelete} onCommentUpdate={this.handleCommentUpdate}/>        <CommentForm onCommentSubmit={this.handleCommentSubmit} />      </div>    );   }   }); ]]></script>And voila, hopefully it's a working. I'm not sure it's the right or the most efficient way of doing things but it covers things that I wish were included in the original tutorial.   